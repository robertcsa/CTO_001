"""
Signal model for trading signals generated by strategies
"""
from datetime import datetime
from enum import Enum as PyEnum
from typing import Optional, Dict, Any
from sqlalchemy import Column, String, DateTime, ForeignKey, Numeric, Index
from sqlalchemy.orm import relationship
from core.db import Base


class SignalType(PyEnum):
    """Trading signal types"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class Signal(Base):
    """Trading signal model"""
    __tablename__ = "signals"
    
    id = Column(String, primary_key=True)
    bot_id = Column(String, ForeignKey("bots.id"), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    signal_type = Column(String, nullable=False, index=True)  # Using string for enum
    confidence = Column(Numeric(precision=4, scale=3), nullable=False)  # 0.000 to 1.000
    reason = Column(String, nullable=True)  # Human-readable reason for signal
    inputs_hash = Column(String, nullable=False, index=True)  # Hash of inputs for audit
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Additional metadata
    meta = Column('metadata', nullable=True)  # JSON metadata
    
    # Relationships
    bot = relationship("Bot", back_populates="signals")
    orders = relationship("Order", back_populates="signal", cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index('idx_signal_bot_time', 'bot_id', 'timestamp', 'signal_type'),
        Index('idx_signal_time_type', 'timestamp', 'signal_type'),
    )
    
    def __repr__(self):
        return f"<Signal(bot_id={self.bot_id}, type={self.signal_type}, confidence={self.confidence})>"
    
    @classmethod
    def create(
        cls,
        bot_id: str,
        timestamp: datetime,
        signal_type: SignalType,
        confidence: float,
        reason: Optional[str] = None,
        inputs_hash: Optional[str] = None,
        meta: Optional[Dict[str, Any]] = None
    ) -> 'Signal':
        """Create signal instance"""
        return cls(
            id=f"{bot_id}_{timestamp.isoformat()}_{signal_type.value}",
            bot_id=bot_id,
            timestamp=timestamp,
            signal_type=signal_type.value,
            confidence=confidence,
            reason=reason,
            inputs_hash=inputs_hash or "",
            metadata=meta
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'id': self.id,
            'bot_id': self.bot_id,
            'timestamp': self.timestamp.isoformat(),
            'signal_type': self.signal_type,
            'confidence': float(self.confidence),
            'reason': self.reason,
            'inputs_hash': self.inputs_hash,
            'meta': self.metadata,
            'created_at': self.created_at.isoformat()
        }
    
    @property
    def is_buy_signal(self) -> bool:
        """Check if signal is a buy signal"""
        return self.signal_type == SignalType.BUY.value
    
    @property
    def is_sell_signal(self) -> bool:
        """Check if signal is a sell signal"""
        return self.signal_type == SignalType.SELL.value
    
    @property
    def is_hold_signal(self) -> bool:
        """Check if signal is a hold signal"""
        return self.signal_type == SignalType.HOLD.value
    
    @property
    def confidence_level(self) -> str:
        """Get confidence level as string"""
        conf = float(self.confidence)
        if conf >= 0.8:
            return "high"
        elif conf >= 0.6:
            return "medium"
        elif conf >= 0.4:
            return "low"
        else:
            return "very_low"